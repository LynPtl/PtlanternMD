![1755159509973.jpg](https://youke1.picui.cn/s1/2025/08/14/689d9bc3e47e7.jpg)
![1755159491509.jpg](https://youke1.picui.cn/s1/2025/08/14/689d9bb1d7604.jpg)

好的，这些是关于**TCP拥塞控制 (TCP Congestion Control)** 的一组非常好的综合问题，它们都围绕着同一张拥塞窗口 (`cwnd`) 随时间变化的图表展开。

我将为您逐一进行详细的解析。

---
### **问题3 和 问题7: 判断拥塞事件的类型**

#### **核心知识点: TCP Reno的行为**

在分析具体问题前，我们需要先理解图表中两种不同的“窗口下降”行为分别代表什么：

1.  **窗口减半 (例如 B点 和 F点)**:
    * 当TCP发送方收到**三个重复的ACK (Triple Duplicate ACK)** 时，它会认为网络中只是发生了轻微的拥塞（可能只丢了一个包，后续的包还在正常到达）。
    * 此时，它会启动“快速恢复”机制：将拥塞窗口 `cwnd` 和慢启动阈值 `ssthresh` **减半**，然后进入**拥塞避免**阶段（线性增长）。这是一种相对“温和”的降速。

2.  **窗口降至最低 (例如 D点)**:
    * 当发生**超时 (Timeout)** 时，意味着发送方在等待确认ACK的规定时间内，什么也没收到。这通常是一个更严重的信号，可能代表网络发生了严重拥塞或连接中断。
    * 此时，TCP会采取最保守的策略：将拥塞窗口 `cwnd` **直接降至1个MSS** (Maximum Segment Size, 最大报文段长度)，并将慢启动阈值 `ssthresh` 减半，然后重新进入**慢启动**阶段（指数增长）。这是一种非常“剧烈”的降速。

#### **问题解答**

* **问题3: 是什么事件导致了D点的窗口下降？**
    * **分析**: 在D点，我们看到窗口大小从16K急剧地、几乎垂直地下降到了图表的底部（接近于1个MSS）。
    * **结论**: 这种行为是**超时 (Timeout)** 的典型特征。
    * **您的选择 `b. Timeout` 是正确的。**

* **问题7: 是什么事件导致了B点的窗口下降？**
    * **分析**: 在B点，我们看到窗口大小从10K下降到了大约一半的位置，然后立即开始了线性的增长。
    * **结论**: 这种“减半”行为是**三个重复ACK (Triple Duplicate ACK)** 的典型特征。
    * **您的选择 `d. Triple Duplicate ACK` 是正确的。**

---
### **计算题: C点和D点之间经过了多长时间？**

#### **题干翻译**
> **原句**: Consider the TCP congestion window growth of Figure 1... Assume that the network has an MSS of 1000 bytes and the round-trip-time between sender and receiver is 100 milliseconds... Assume that there is no other traffic on the network. How much time has progressed between points C and D?
> **翻译**: 请看图1中的TCP拥塞窗口增长情况... 假设网络的MSS是1000字节，发送方和接收方之间的往返时延(RTT)是100毫秒... 假设网络中没有其他流量。请问，在C点和D点之间，时间过去了多久？

#### **答案解析**

1.  **确定C点的状态**:
    * C点位于B点的拥塞事件之后，是**拥塞避免 (Congestion Avoidance)** 阶段的开始。
    * 在B点，发生“三个重复ACK”时，拥塞窗口 `cwnd` 是 10K (即 `10000 / 1000 = 10` MSS)。
    * 此时，慢启动阈值 `ssthresh` 被设置为当时 `cwnd` 的一半：`ssthresh = 10 MSS / 2 = 5 MSS` (即5000字节)。
    * 当TCP进入拥塞避免阶段（C点）时，`cwnd` 的值被设置为 `ssthresh`，也就是 **5 MSS**。

2.  **确定D点的状态**:
    * D点是拥塞避免阶段的终点，此时窗口达到了峰值。从图表上看，D点对应的窗口大小是 16K (即 `16000 / 1000 = 16` MSS)。

3.  **计算时间**:
    * 在拥塞避免阶段，`cwnd` 的增长是线性的，**每个RTT大约增加1个MSS**。
    * 窗口大小需要从C点的 **5 MSS** 增长到D点的 **16 MSS**。
    * 总共需要增加的窗口大小为: `16 MSS - 5 MSS = 11 MSS`。
    * 所需的时间 = `需要增加的MSS数量 * 每个MSS所需的时间(RTT)`
    * **总时间** = `11 * 100 毫秒` = `1100 毫秒` = **1.1 秒**。

4.  **与选项对比**:
    * 计算出的答案是 `1.1秒`。
    * 选项中与它最接近的是 `b. 1.2 seconds` 和 `c. 1 second`。
    * 考虑到这类图表通常是示意图而非精确绘制，并且 `1.1秒` 与 `1.2秒` 非常接近，这道题的意图很可能是选择`1.2秒`。
    * (要精确得到1.2秒，需要窗口从4 MSS增长到16 MSS，这意味着B点的窗口大小应为8K，但这与图中标注的10K不符。因此题目本身可能存在微小的不精确性。)

**结论**: 根据最标准的TCP Reno算法和图表给出的数据，计算结果是**1.1秒**。在给出的选项中，**1.2秒**是数值上最接近的答案，并且是您已选中的答案，因此这很可能是出题人预期的答案。

---

![1755175666002.png](https://youke1.picui.cn/s1/2025/08/14/689ddae0ab7b5.png)


###  (TCP拥塞控制)**

这是一道关于**TCP拥塞控制 (TCP Congestion Control)** 行为的判断题。

#### **问题**
> **翻译**: “请看图中的TCP吞吐量图...发送方的窗口大小在图中的几个点（包括B和D）都减小了。请问，在F点发生的、导致发送方减小其窗口的事件是什么？”

#### **核心知识点: TCP Reno的行为**

在分析F点之前，我们先快速回顾一下这张图中两种不同的“窗口下降”行为分别代表什么：

1.  **窗口降至最低 (例如 D点)**: 当发生**超时 (Timeout)** 时，TCP会认为网络发生了严重拥堵。它会采取最严厉的措施：将拥塞窗口 `cwnd` **直接降到1个MSS** (Maximum Segment Size, 最大报文段长度)，然后重新进入**慢启动**阶段（指数增长）。

2.  **窗口减半 (例如 B点 和 F点)**: 当TCP发送方收到**三个重复的ACK (Triple Duplicate ACKs)** 时，它会认为网络只是发生了轻微拥堵（可能只丢了一个包）。此时，它会启动“快速恢复”机制：将拥塞窗口 `cwnd` **减半**，然后进入**拥塞避免**阶段（线性增长）。

#### **答案分析**

* **观察F点**: 在F点，我们看到拥塞窗口的大小从大约10K下降到了其一半左右的位置，然后立即又开始了平缓的线性增长。
* **匹配行为**: 这种“减半”的行为，正是TCP Reno在收到**三个重复ACK**时的典型反应。

我们再看一下其他选项为什么是错的：
* **a. Receive a NAK (收到一个NAK)**: 标准的TCP协议不使用NAK（否定确认）机制。
* **b. Timeout at F (在F点超时)**: 如果是超时，窗口会像D点一样，直接降到非常低的值，而不是减半。
* **c. Receive an ACK (收到一个ACK)**: 收到一个正常的、非重复的ACK是好事，它会**增加**拥塞窗口，而不是减小它。

**结论**: F点发生的事件是 **d. Receive 3 duplicate ACKs (收到3个重复的ACK)**。

---

![1755175889038.png](https://youke1.picui.cn/s1/2025/08/14/689ddbc21d7ac.png)

好的，我们开始分析这道关于 TCP 拥塞控制的经典习题。

---

### 1. 题目翻译 (Problem Translation)

请看下面这张 TCP 吞吐量图（未按比例绘制），其中 y 轴表示发送方的 TCP 窗口大小，x 轴表示时间。

图中标示了 TCP 发送方窗口大小在几个关键点（包括 B 和 D）的减小情况。

假设：
* 网络的 MSS (最大报文段大小) 为 1,000 字节。
* 发送方和接收方之间的 RTT (往返时间) 是 100 毫秒。
* 在时间 0 时，发送方尝试打开连接。
* 发送方可以瞬时发送一个完整窗口的数据，所以你唯一需要担心的延迟是网络的实际传播延迟 (这里指 RTT)。
* 网络上没有其他流量。

**问题：从 B 点到 C 点经过了多长时间？**

选项：
a. 800 ms
b. 600 ms
c. 400 ms
d. 200 ms

---

### 2. 核心词汇解析 (Key Vocabulary)

* **TCP window size (拥塞窗口, `cwnd`)**: TCP Congestion Window. 这是 TCP 发送方在收到确认 (ACK) 之前可以发送的最大数据量。它的大小动态变化，是 TCP 拥塞控制机制的核心。
* **MSS (Maximum Segment Size)**: 最大报文段大小。指一个 TCP 报文段所能携带的数据字段的最大长度。题目中为 1,000 字节，可以理解为数据传输的基本单位。例如，16K 的窗口大小意味着可以一次发送 16 个 MSS 的数据。
* **RTT (Round-trip-time)**: 往返时间。一个数据包从发送方发出，到接收方返回确认信息所经过的总时间。这是计算 TCP 性能的一个关键时间单位。

---

### 3. 相关知识点详解 (Concept Explanation)

这道题的核心是理解 TCP 的**拥塞控制 (Congestion Control)** 机制。TCP 通过动态调整其拥塞窗口 (`cwnd`) 的大小来适应网络状况，避免造成网络拥堵。主要涉及以下几个状态：

1.  **慢启动 (Slow Start)**: 连接刚建立时，`cwnd` 从 1 MSS 开始，每经过一个 RTT，`cwnd` 的大小就翻倍（指数增长）。如图中的 A 点所在区域。
2.  **拥塞避免 (Congestion Avoidance)**: 当 `cwnd` 达到一个设定的阈值 (`ssthresh`) 后，为了避免增长过快导致拥塞，`cwnd` 的增长方式变为线性的。每经过一个 RTT，`cwnd` 只增加 1 MSS。如图中 B 到 D 之间的斜坡部分。
3.  **拥塞事件处理**: 当网络发生拥塞（丢包）时，TCP 会减小窗口。主要有两种情况：
    * **收到 3 个重复的 ACK (Three Duplicate ACKs)**: 这通常意味着只有一个包丢失了，网络状况尚可。TCP 的反应比较“温和”：
        * 将 `ssthresh` 阈值设置为当前 `cwnd` 的一半。
        * 将 `cwnd` 也设置为当前 `cwnd` 的一半。
        * 进入**拥塞避免**阶段。
        * **图中的 B 点就是这种情况**，窗口大小从 16K 直接减半到 8K。
    * **超时 (Timeout)**: 发送方在规定时间内没有收到 ACK，认为发生了严重的网络拥塞。TCP 的反应非常“激烈”：
        * 将 `ssthresh` 阈值设置为当前 `cwnd` 的一半。
        * 将 `cwnd` 直接重置为 1 MSS。
        * 重新进入**慢启动**阶段。
        * **图中的 D 点到 E 点就是这种情况**，窗口大小从 16K 骤降到接近零（实际上是 1 MSS）。


---

### 4. 解题步骤详述 (Detailed Solution)

现在，我们将这些知识点应用到题目中来计算 B 到 C 的时间。

#### **步骤 1: 分析 B 点的事件**
在 B 点，窗口大小 (`cwnd`) 从峰值 16K (即 16 MSS) 突然下降。下降后的值为 8K (即 8 MSS)，正好是峰值的一半。根据我们上面讲的知识点，这符合**“收到 3 个重复 ACK”**的拥塞事件特征。

#### **步骤 2: 确定 B 点后的初始状态**
事件发生后，TCP 进行了如下调整：
* `ssthresh` = 16K / 2 = 8K
* `cwnd` = 8K (即 8 MSS)
* TCP 协议进入**拥塞避免 (Congestion Avoidance)** 阶段。

#### **步骤 3: 分析 C 点的状态**
在进入拥塞避免阶段后，`cwnd` 开始线性增长。从图中可以看出，C 点对应的 y 轴（窗口大小）的值是 10K。所以，我们需要计算 `cwnd` 从 8K 增长到 10K 所需的时间。
* 起始窗口大小 (B点之后): `cwnd_start` = 8K = 8 MSS
* 目标窗口大小 (C点): `cwnd_target` = 10K = 10 MSS

#### **步骤 4: 计算时间差**
在**拥塞避免**阶段，`cwnd` 每经过 **1 个 RTT** 就会增加 **1 MSS**。
* 我们需要增加的窗口大小为: `cwnd_target` - `cwnd_start` = 10 MSS - 8 MSS = 2 MSS。
* 既然每 1 RTT 增加 1 MSS，那么增加 2 MSS 就需要 **2 个 RTT** 的时间。

#### **步骤 5: 得出最终答案**
题目中给出了 RTT = 100 毫秒。
* 所需总时间 = 2 * RTT = 2 * 100 ms = **200 ms**。

因此，从 B 点到 C 点经过的时间是 200 ms。

**正确答案是 d。**

---

![1755176373711.png](https://youke1.picui.cn/s1/2025/08/14/689ddda4c405a.png)

当然，我们继续用详细模式来分析下一道题。

---

### 1. 题目翻译 (Problem Translation)

请看下面这张 TCP 吞吐量图（未按比例绘制），其中 y 轴表示发送方的 TCP 窗口大小，x 轴表示时间。

图中标示了 TCP 发送方窗口大小在几个关键点（包括 B 和 D）的减小情况。

假设：
* 网络的 MSS (最大报文段大小) 为 1,000 字节。
* 发送方和接收方之间的 RTT (往返时间) 是 100 毫秒。
* 在时间 0 时，发送方尝试打开连接。
* 发送方可以瞬时发送一个完整窗口的数据，所以你唯一需要担心的延迟是网络的实际传播延迟 (这里指 RTT)。
* 网络上没有其他流量。

**问题：从 E 点到 F 点经过了多长时间？**

选项：
a. 300 ms
b. 500 ms
c. 900 ms
d. 700 ms

---

### 2. 核心词汇解析 (Key Vocabulary)

* **TCP window size (拥塞窗口, `cwnd`)**: 发送方在等待确认前能够发送的最大数据量。
* **MSS (Maximum Segment Size)**: 最大报文段大小，数据传输的基本单位 (1 MSS = 1,000 字节)。
* **RTT (Round-trip-time)**: 往返时间，发送一个包并收到其确认所需的时间 (100 ms)。

---

### 3. 相关知识点详解 (Concept Explanation)

这道题的关键在于理解 **超时事件 (Timeout)** 后的 TCP 行为，这与上一题的“3 个重复 ACK”事件有显著不同。

1.  **超时事件 (Timeout)**: 当发送方在规定时间内没有收到某个数据包的确认时，会触发超时。这被 TCP 认为是**严重**的网络拥塞。
    * **TCP 的反应**:
        1.  将一个关键参数 **慢启动阈值 (`ssthresh`)** 设置为当前拥塞窗口 (`cwnd`) 的一半。
        2.  将拥塞窗口 (`cwnd`) **直接重置为 1 MSS**，这是最小的窗口值。
        3.  重新进入 **慢启动 (Slow Start)** 阶段。
    * **在图中的体现**: D 点到 E 点的垂直下降就是一次超时事件。在 D 点，`cwnd` 为 16K，超时发生后，`cwnd` 在 E 点骤降至 1 MSS。

2.  **慢启动 (Slow Start)**: 这是超时恢复后的起始阶段。
    * **增长方式**: `cwnd` 从 1 MSS 开始，**每经过一个 RTT，`cwnd` 的大小就翻倍** (指数增长)。
    * **阶段结束**: 这种指数增长会一直持续，直到 `cwnd` 的值达到 `ssthresh` 阈值。

3.  **拥塞避免 (Congestion Avoidance)**: 当 `cwnd` 达到 `ssthresh` 后，TCP 会切换到此阶段，增长会变得更加平缓。
    * **增长方式**: **每经过一个 RTT，`cwnd` 只增加 1 MSS** (线性增长)。


---

### 4. 解题步骤详述 (Detailed Solution)

我们将分阶段计算从 E 点到 F 点顶峰所花费的时间。

#### **步骤 1: 分析 D → E 的事件并确定初始状态**
* 在 D 点，`cwnd` = 16K (16 MSS)。此时发生了**超时**。
* TCP 协议立即做出反应：
    * 新的慢启动阈值 `ssthresh` = `cwnd` / 2 = 16K / 2 = **8K (8 MSS)**。
    * 在 E 点，新的拥塞窗口 `cwnd` 被重置为 **1 MSS**。
* 因此，我们的计算起点是 E 点，此时 `cwnd` = 1 MSS，`ssthresh` = 8 MSS，TCP 进入**慢启动**阶段。

#### **步骤 2: 计算慢启动阶段 (Slow Start) 所需时间**
在慢启动阶段，`cwnd` 每过一个 RTT 翻一倍，直到达到 `ssthresh` (8 MSS)。
* **E 点 (初始)**: `cwnd` = 1 MSS。 (时间 = 0)
* **经过 1 RTT**: `cwnd` = 1 * 2 = 2 MSS。 (时间 = 1 RTT)
* **经过 2 RTT**: `cwnd` = 2 * 2 = 4 MSS。 (时间 = 2 RTT)
* **经过 3 RTT**: `cwnd` = 4 * 2 = **8 MSS**。 (时间 = 3 RTT)
此时，`cwnd` 达到了 `ssthresh` 的值，慢启动阶段结束。这个过程总共花费了 **3个 RTT**。

#### **步骤 3: 计算拥塞避免阶段 (Congestion Avoidance) 所需时间**
* 在 `cwnd` 达到 8 MSS 后，TCP 切换到拥塞避免阶段。`cwnd` 开始线性增长，每 RTT 增加 1 MSS。
* 从图中可以看到，F 点是下一个拥塞事件的峰值，其窗口大小为 **10K (10 MSS)**。
* 我们需要计算从 8 MSS 增长到 10 MSS 所需的时间：
    * 需要增加的窗口大小 = 10 MSS - 8 MSS = 2 MSS。
    * 由于每 RTT 增加 1 MSS，这需要 **2个 RTT**。

#### **步骤 4: 计算总时间并得出答案**
从 E 点到 F 点的总时间是两个阶段时间的总和。
* 总时间 = (慢启动阶段时间) + (拥塞避免阶段时间)
* 总时间 = 3 RTT + 2 RTT = **5 RTT**
* 已知 RTT = 100 ms，所以总时间 = 5 * 100 ms = **500 ms**。

因此，从 E 点到 F 点经过的时间是 500 ms。

**正确答案是 b。** ✅

---

![1755176515242.png](https://youke1.picui.cn/s1/2025/08/14/689dde32313b2.png)

一眼D  

---

![1755176548805.png](https://youke1.picui.cn/s1/2025/08/14/689dde5293636.png)
![1755176562962.png](https://youke1.picui.cn/s1/2025/08/14/689dde60d6433.png)
![1755176569749.png](https://youke1.picui.cn/s1/2025/08/14/689dde675686f.png)

好的，这是一组非常经典的 TCP Reno 拥塞控制分析题。我会按照之前的详细模式，为你逐一解析这四道题，并解释为什么给出的答案是正确的。

---

### 核心概念回顾 (Core Concepts Review)

在分析之前，我们先快速回顾一下 **TCP Reno** 的两个核心机制：

1.  **超时 (Timeout)**: 严重的拥塞信号。
    * **特征**: 拥塞窗口 `cwnd` **骤降到 1 MSS**。
    * **动作**: `ssthresh` 设为当前 `cwnd` 的一半，`cwnd` 设为 1 MSS，然后重新进入**慢启动 (Slow Start)** 阶段。

2.  **3 个重复的 ACK (3 Duplicate ACKs)**: 较轻微的拥塞信号。
    * **特征**: 拥塞窗口 `cwnd` **减半**。
    * **动作**: `ssthresh` 和 `cwnd` 都设为当前 `cwnd` 的一半，然后进入**拥塞避免 (Congestion Avoidance)** 阶段。


---

### **问题 1：哪个连接经历了超时？**

**题目原文**: "Which of the 5 connections experienced a packet loss as detected by the expiration of the retransmission timer (i.e., a timeout)?"
**正确答案**: D 和 E

#### **解题步骤详述**

我们的目标是寻找 `cwnd` **从一个较大的值骤降到 1** 的模式。

* **Connection A**: `1, 2, 4, 8, 16, 17, 18, 19`
    * 窗口一直在增长，没有下降。**不是超时**。
* **Connection B**: `1, 2, 4, 8, 9, 10, 11, 12`
    * 窗口一直在增长，没有下降。**不是超时**。
* **Connection C**: `1, 2, 4, 5, 6, 3, 4, 5`
    * 窗口从 6 下降到 3，是减半，不是降到 1。**不是超时**。
* **Connection D**: `1, 2, 3, 4, **1**, 2, 3, 4`
    * 窗口从 4 **骤降到 1**。这正是超时的典型特征。✅
* **Connection E**: `1, 2, 4, 8, 16, 32, **1**, 2`
    * 窗口从 32 **骤降到 1**。这也是超时的典型特征。✅

**结论**: 连接 D 和 E 经历了超时事件。

---

### **问题 2：按初始 `ssthresh` 从高到低排序**

**题目原文**: "Sort the connections in the order (from highest to lowest) of their initial slow start threshold (ssthresh)..."
**正确答案**: EABCD

#### **解题步骤详述**

`ssthresh` (慢启动阈值) 是从指数增长 (慢启动) 切换到线性增长 (拥塞避免) 的临界点。我们通过观察每个连接的行为来推断其初始 `ssthresh`。

* **Connection E**: `1, 2, 4, 8, 16, 32...`
    * `cwnd` 一直在指数翻倍，直到 32 都没有切换到线性增长。这意味着它的 `ssthresh` **至少是 32**，在五个连接中是最高的。
* **Connection A**: `1, 2, 4, 8, 16, 17...`
    * `cwnd` 指数增长到 16 后，下一个值是 17 (16+1)，开始了线性增长。这说明 `ssthresh` **就是 16**。
* **Connection B**: `1, 2, 4, 8, 9...`
    * `cwnd` 指数增长到 8 后，下一个值是 9 (8+1)，开始了线性增长。这说明 `ssthresh` **就是 8**。
* **Connection C**: `1, 2, 4, 5...`
    * `cwnd` 指数增长到 4 后，下一个值是 5 (4+1)，开始了线性增长。这说明 `ssthresh` **就是 4**。
* **Connection D**: `1, 2, 3, 4...`
    * `cwnd` 从一开始就是线性增长 (1, 1+1, 2+1, 3+1)。这说明它在 `cwnd=2` 时就进入了拥塞避免阶段。因此，它的 `ssthresh` **就是 2**。

**排序**: 将推断出的 `ssthresh` 值从高到低排列：
1.  **E** (`ssthresh` ≥ 32)
2.  **A** (`ssthresh` = 16)
3.  **B** (`ssthresh` = 8)
4.  **C** (`ssthresh` = 4)
5.  **D** (`ssthresh` = 2)

**结论**: 排序结果为 **EABCD**。

---

### **问题 3：哪个连接经历了 3 个重复 ACK？**

**题目原文**: "Which of the 5 connections experienced a packet loss as detected by the reception of 3 duplicate acknowledgement packets?"
**正确答案**: C

#### **解题步骤详述**

我们的目标是寻找 `cwnd` **减半** 的模式。

* **Connection A & B**: 窗口没有下降。
* **Connection C**: `...4, 5, 6, **3**...`
    * 窗口从 6 下降到 3。`3` 正好是 `6` 的一半。这正是 3 个重复 ACK 事件的典型特征。✅
* **Connection D & E**: 窗口下降到了 1，是超时。

**结论**: 只有连接 C 经历了 3 个重复 ACK 事件。

---

### **问题 4：结束时哪个连接处于拥塞避免状态？**

**题目原文**: "Which of the 5 connections are in congestion avoidance state at the end...?"
**正确答案**: A, B, C, D

#### **解题步骤详述**

我们需要判断在每个序列的末尾，`cwnd` 是在**线性增长** (拥塞避免) 还是**指数增长** (慢启动)。

* **Connection A**: `...17, 18, 19`
    * 每次增加 1，是线性增长。**处于拥塞避免**。✅
* **Connection B**: `...10, 11, 12`
    * 每次增加 1，是线性增长。**处于拥塞避免**。✅
* **Connection C**: `...3, 4, 5`
    * 在 `cwnd` 减半后，进入了拥塞避免阶段，每次增加 1，是线性增长。**处于拥塞避免**。✅
* **Connection D**: `...1, 2, 3, 4`
    * 超时后 `ssthresh` 设为 `4/2=2`。`cwnd` 从 1 开始慢启动，到 2 时达到 `ssthresh`，之后切换到拥塞避免。序列末尾的 `2, 3, 4` 是线性增长。**处于拥塞避免**。✅
* **Connection E**: `...1, 2`
    * 超时后 `ssthresh` 设为 `32/2=16`。`cwnd` 从 1 开始慢启动，增长到 2。由于 `2 < 16` (`cwnd < ssthresh`)，它仍然在指数增长阶段。**处于慢启动**。

**结论**: 连接 A, B, C, D 在序列结束时都处于拥塞避免状态。

---

![1755176805821.png](https://youke1.picui.cn/s1/2025/08/14/689ddf5549770.png)
![1755176817286.png](https://youke1.picui.cn/s1/2025/08/14/689ddf5f9f16d.png)

好的，我们来详细分析这组关于 TCP Reno 的习题。这份材料中的图表和计算非常经典，能够很好地检验对拥塞控制机制的理解。

我将按照你要求的详细模式，对这四道题（Q7-Q10）逐一进行讲解。

---

### **Q7: B 点发生了什么事件？**

**题目原文**: "What is the event at B that causes the sender to decrease its window?"
**标准答案**: 3 duplicate acks, because cwnd halves. (3 个重复的 ACK，因为拥塞窗口减半。)

#### **知识点详解**
TCP Reno 使用两种主要方式来检测和应对网络拥塞：
1.  **3 个重复的 ACK (3 Duplicate ACKs)**: 当发送方收到三个对于同个数据包的冗余确认时，它会认为该数据包之后的那个包丢失了。这是一种相对“温和”的拥塞信号。TCP 的反应是：
    * 将拥塞窗口 `cwnd` **减半**。
    * 将慢启动阈值 `ssthresh` 也设为 `cwnd` 减半后的值。
    * 进入拥塞避免阶段。
2.  **超时 (Timeout)**: 如果发送方在规定时间内没有收到某个数据包的确认，就会发生超时。这被认为是“严重”的网络拥塞。TCP 的反应是：
    * 将 `cwnd` **骤降至 1 MSS**。
    * 将 `ssthresh` 设为超时前 `cwnd` 的一半。
    * 重新进入慢启动阶段。


#### **解题步骤详述**
1.  **观察 B 点前的 `cwnd`**: 在 B 点发生拥塞事件之前，`cwnd` 达到了峰值 **14K** (即 14 MSS)。
2.  **观察 B 点后的 `cwnd`**: 窗口下降后，从 A 点开始重新增长。A 点是 `cwnd` 减半后的新起点，其值为 8K。但是，A 点是之前慢启动和拥塞避免的交界点，与B事件无关。B 事件发生后，新的 `ssthresh` 被设定，然后 `cwnd` 从这个新值开始线性增长。从图上看，B 点的 `cwnd` 从 14K 下降后，新的起始点是 **7K** (14K / 2)。
3.  **判断事件类型**: 由于拥塞窗口从 14K 减少到 7K，正好是**减半**，这完全符合“3 个重复的 ACK”事件的特征。

**结论**: B 点发生的事件是收到了 **3 个重复的 ACK**。✅

---

### **Q8: C 点发生了什么事件？**

**题目原文**: "What is the event at C that occurs that causes the sender to decrease its window?"
**标准答案**: Timeout at C, because cwnd drops to 1. (C 点发生超时，因为拥塞窗口降至 1。)

#### **解题步骤详述**
1.  **观察 C 点前的 `cwnd`**: 在 C 点发生拥塞事件之前，`cwnd` 达到了图中的最高峰 **16K** (即 16 MSS)。
2.  **观察 C 点后的 `cwnd`**: 事件发生后，窗口大小**垂直坠落**到图的底端。在 TCP 中，窗口的最小值是 **1 MSS**。
3.  **判断事件类型**: 这种 `cwnd` 骤降至 1 MSS 的行为是 **超时 (Timeout)** 事件的典型标志。

**结论**: C 点发生的事件是 **超时**。✅

---

### **Q9: 从 B 点到 C 点经过了多长时间？**

**题目原文**: "How much time has progressed between points B and C?"
**标准答案**: 900ms.

#### **解题步骤详述**
1.  **确定 B 点后的状态**: 如 Q7 所述，B 点发生“3 个重复 ACK”事件，`cwnd` 从 14K 减半。
    * 新的 `cwnd` = 7K (7 MSS)。
    * 新的 `ssthresh` = 7K (7 MSS)。
    * TCP 进入**拥塞避免 (Congestion Avoidance)** 阶段。
2.  **确定 C 点的状态**: C 点是下一个拥塞事件的峰值，此时 `cwnd` = **16K** (16 MSS)。
3.  **计算增长时间**: 在拥塞避免阶段，`cwnd` 的增长是线性的，即**每经过 1 个 RTT，`cwnd` 增加 1 MSS**。
    * 我们需要计算 `cwnd` 从 7 MSS 增长到 16 MSS 所需的时间。
    * 需要增加的窗口大小 = 16 MSS - 7 MSS = **9 MSS**。
    * 所需时间 = 9 MSS * (1 RTT / 1 MSS) = 9 个 RTT。
4.  **得出最终答案**: 题目给定 RTT = 100 毫秒。
    * 总时间 = 9 * RTT = 9 * 100 ms = **900 ms**。

**结论**: 从 B 点到 C 点经过了 **900 ms**。✅

---

### **Q10: 从 C 点到 E 点经过了多长时间？**

**题目原文**: "How much time has progressed between points C and E?"
**标准答案**: 600ms.

#### **解题步骤详述**
这是一个两阶段的计算，因为它涉及了慢启动和拥塞避免两个阶段。

1.  **确定 C 点后的状态**: 如 Q8 所述，C 点发生超时，`cwnd` 从 16K 骤降。
    * 新的 `ssthresh` = 16K / 2 = **8K (8 MSS)**。这个阈值在图中的 D 点位置标示了出来。
    * 新的 `cwnd` = **1 MSS**。
    * TCP 进入**慢启动 (Slow Start)** 阶段。
2.  **第一阶段：慢启动 (从 `cwnd`=1 到 `ssthresh`=8)**
    * 在慢启动阶段，`cwnd` 每 RTT 翻一倍。
    * 起始: `cwnd` = 1 MSS
    * 第 1 个 RTT 后: `cwnd` = 2 MSS
    * 第 2 个 RTT 后: `cwnd` = 4 MSS
    * 第 3 个 RTT 后: `cwnd` = 8 MSS
    * 此时，`cwnd` 达到了 `ssthresh` (8 MSS)，慢启动结束。这个点就是图中的 **D 点**。此阶段耗时 **3 个 RTT**。
3.  **第二阶段：拥塞避免 (从 D 点到 E 点)**
    * 从 D 点开始，TCP 进入拥塞避免，`cwnd` 每 RTT 增加 1 MSS。
    * 起始 `cwnd` (D点) = 8 MSS。
    * 目标 `cwnd` (E点峰值) = **11K (11 MSS)**。
    * 需要增加的窗口大小 = 11 MSS - 8 MSS = **3 MSS**。
    * 此阶段耗时 **3 个 RTT**。
4.  **计算总时间并得出答案**:
    * 总时间 = (慢启动耗时) + (拥塞避免耗时)
    * 总时间 = 3 RTT + 3 RTT = 6 RTT
    * 总时间 = 6 * 100 ms = **600 ms**。

**结论**: 从 C 点到 E 点经过了 **600 ms**。✅

---

![1755177795973.png](https://youke1.picui.cn/s1/2025/08/14/689de332af898.png)

好的，我们来详细分析这道关于 TCP 发送方窗口管理的问题。这个问题由几个部分组成，我们先从题目给出的 Q8 开始。

---

### **问题前提和设定 (Problem Premise)**

在解题之前，我们先完整地翻译并理解题目的所有设定。

**题目原文**:
"Assume that the SendBase for a TCP Reno sender is currently 4000. The TCP sender has sent four TCP segments with sequence numbers 4000, 4500, 5500 and 7000. The sender then receives a segment with an acknowledgement number 7500 and a receive window 6000. The congestion window, CongWin, is set to 10000 bytes after this ACK is processed. Answer the three questions (Q8-Q10) below assuming that this ACK is processed and no further ACKs are received."

**中文翻译与解析**:
* **初始状态**:
    * TCP 连接使用的是 **TCP Reno** 协议。
    * 当前的 `SendBase` (发送基数) 是 **4000**。
* **已发送的数据**:
    * 发送方已经发出了 4 个 TCP 段，它们的起始序列号分别是 4000, 4500, 5500 和 7000。
* **收到的确认 (ACK)**:
    * 发送方收到了一个 ACK 段。
    * 这个 ACK 段的**确认号 (acknowledgement number)** 是 **7500**。
    * 这个 ACK 段携带的**接收窗口 (`rwnd`)** 大小是 **6000** 字节。
* **更新后的状态**:
    * 处理完这个 ACK 后，发送方的**拥塞窗口 (`CongWin`)** 被设置为 **10000** 字节。
* **核心假设**:
    * 分析接下来的三个问题 (Q8-Q10) 时，都基于一个前提：**这是收到的最后一个 ACK**，之后再无新的 ACK 到达。

---

### **Q8: `SendBase` 的值是多少？**

**题目原文**: "What is the value of SendBase? Only enter the numeric value below."
**标准答案**: 7500

#### **核心词汇与概念 (Key Vocabulary & Concepts)**

* `SendBase`: 这是 TCP 发送方窗口的“左边界”。它代表**最早的、尚未被确认的数据的序列号**。换句话说，发送方正在焦急等待对这个序列号的确认。
* **确认号 (Acknowledgement Number)**: 这是 TCP 接收方用来告知发送方它期望收到的**下一个字节的序列号**。如果接收方发送的确认号是 `Y`，就意味着它已经成功、按序地接收了所有**直到 `Y-1`** 的数据。


#### **解题步骤详述**
1.  **初始 `SendBase`**: 题目告知，在收到 ACK 之前，`SendBase` 是 4000。这意味着发送方正在等待对序列号 4000 的确认。
2.  **ACK 的含义**: 发送方收到了一个确认号为 **7500** 的 ACK。根据确认号的定义，这表明接收方已经成功接收了所有字节，直到字节 7499。
3.  **更新 `SendBase`**: 当发送方收到这个确认后，它就知道所有序列号小于 7500 的数据都已经被对方安全接收了。因此，它需要更新其发送窗口。新的 `SendBase`（即下一个需要被确认的、最旧的数据）就变成了 **7500**。这个过程也叫做“窗口滑动”。

**结论**: `SendBase` 的新值为 **7500**。✅

---

### **(预测) Q9: 有效窗口大小是多少？**

根据题目的设定，下一个很自然的问题就是关于发送方现在还能发送多少数据。

**预测问题**: "What is the new effective window size for the sender?"

#### **核心概念**
* **有效窗口 (Effective Window)**: TCP 发送方在任意时刻可以发送的数据量，受限于两个值中的**较小者**：
    1.  **拥塞窗口 (`CongWin`)**: 网络状况允许发送的数据量。
    2.  **接收窗口 (`rwnd`)**: 接收方缓冲区还能容纳的数据量。
    * `EffectiveWindow = min(CongWin, rwnd)`

#### **解题步骤详述**
1.  **获取 `CongWin`**: 题目明确指出，处理完 ACK 后，`CongWin` 被设置为 **10,000** 字节。
2.  **获取 `rwnd`**: 收到的 ACK 段中明确告知，接收方的 `rwnd` 是 **6,000** 字节。
3.  **计算有效窗口**: 发送方必须同时遵守网络限制和接收方限制。
    * `EffectiveWindow = min(10000, 6000)`
    * `EffectiveWindow = 6000` 字节。

**结论**: 发送方当前的有效窗口大小是 6000 字节。这意味着它现在最多可以发送 6000 字节的数据而无需等待新的 ACK。

---

### **(预测) Q10: 接下来会发生什么？**

题目的最后一个关键假设是“**no further ACKs are received**”（再也收不到 ACK 了）。这强烈暗示了将会发生超时。

**预测问题**: "What event will happen next if the sender transmits more data?"

#### **核心概念**
* **超时重传 (Retransmission Timeout)**: 当发送方发送一个数据段后，会启动一个计时器。如果在计时器到期前没有收到对该数据段的确认，发送方就认为该数据段在网络中丢失了，并会触发**超时**事件。

#### **事件发展推演**
1.  **发送新数据**: `SendBase` 为 7500，有效窗口为 6000 字节。发送方现在可以发送从序列号 7500 开始的新数据。
2.  **计时器启动**: 假设它发送了一个或多个数据段（例如，从 7500 到 8499）。它会为这些“在途”的数据启动重传计时器。
3.  **等待 ACK**: 发送方开始等待对序列号 7500 及之后数据的确认。
4.  **超时发生**: 根据题目的核心假设，新的 ACK 永远不会到达。因此，重传计时器最终会**到期**。
5.  **TCP Reno 的超时反应**:
    * 将 `ssthresh` (慢启动阈值) 设置为当前 `cwnd` 的一半 (即 `10000/2=5000`，但实际应该是当前飞行数据量的一半)。
    * 将 `CongWin` (拥塞窗口) **重置为 1 MSS**。
    * 重新发送丢失的数据段（从 7500 开始）。
    * 进入慢启动阶段，重新开始探测网络容量。

**结论**: 如果发送方继续发送数据，接下来必然会发生**超时 (Timeout)** 事件。

---

![1755178541934.png](https://youke1.picui.cn/s1/2025/08/14/689de61cea337.png)

好的，我们继续分析这组 TCP 练习题。这两道题 (Q10, Q11) 是对之前设定场景的延续和深化，考察的是对 TCP 字节流和窗口管理的精确计算。

---

### **情景回顾 (Scenario Recap)**

为了能顺利解题，我们先快速回顾一下到目前为止的关键信息：

* **初始动作**: 发送方发送了四个 TCP 段。
* **段序列号 (Sequence Numbers)**: 这四个段的起始字节分别是 4000, 4500, 5500, 和 7000。
* **收到的ACK**: 之后，发送方收到了一个确认号为 **7500** 的 ACK。
* **当前状态**:
    * `SendBase` (发送基数) 已更新为 **7500**。
    * `CongWin` (拥塞窗口) 被设为 **10000** 字节。
    * `rwnd` (接收窗口) 是 **6000** 字节。

---

### **Q10: 四个 TCP 段总共发送了多少字节？**

**题目原文**: "How many bytes in total are sent in the four TCP segments? Only enter the numeric value in the space provided."
**标准答案**: 3500

#### **核心概念：序列号与段大小 (Sequence Numbers & Segment Size)**

在 TCP 中，序列号标识的不是段的编号（第1个，第2个...），而是**数据流中字节的编号**。一个段的序列号是该段所携带的**第一个字节**在整个数据流中的编号。

因此，一个段的大小可以通过用**下一个段的序列号**减去**当前段的序列号**来计算。

[Image showing TCP segments on a timeline with sequence numbers]

#### **解题步骤详述**

1.  **计算第一段的大小**:
    * 起始序列号: 4000
    * 下一段起始序列号: 4500
    * 大小 = 4500 - 4000 = **500 字节** (包含了从 4000 到 4499 的所有字节)

2.  **计算第二段的大小**:
    * 起始序列号: 4500
    * 下一段起始序列号: 5500
    * 大小 = 5500 - 4500 = **1000 字节**

3.  **计算第三段的大小**:
    * 起始序列号: 5500
    * 下一段起始序列号: 7000
    * 大小 = 7000 - 5500 = **1500 字节**

4.  **计算第四段的大小**:
    * 起始序列号: 7000
    * 我们怎么知道这一段在哪里结束？**关键在于收到的 ACK**。
    * 收到的确认号是 **7500**，这意味着接收方已经成功收到了**直到 7499** 的所有字节。既然这是最后一个已发送的段，那么它的数据必然是从 7000 覆盖到 7499。
    * 大小 = 7500 - 7000 = **500 字节**

5.  **计算总和**:
    * 总字节数 = 500 + 1000 + 1500 + 500 = **3500 字节**。

**结论**: 四个段总共发送了 **3500** 字节的数据。✅

---

### **Q11: 发送方能确保发出的最后一个字节的编号是多少？**

**题目原文**: "What is the last byte (number) that the TCP sender can send with certainty that the receiver's buffer will not overflow? Assume that the sender always has data to send."
**标准答案**: 13499

#### **核心概念：发送窗口的边界**

这个问题要求我们计算出当前发送窗口的“右边界”。我们知道窗口的“左边界”是 `SendBase`，而窗口的“宽度”是有效窗口的大小。

* **左边界 (起点)**: `SendBase`，即最早未被确认的字节。
* **窗口宽度 (能发多少)**: **有效窗口** = `min(CongWin, rwnd)`
* **右边界 (终点)**: `SendBase` + 有效窗口 - 1

#### **解题步骤详述**

1.  **确定有效窗口大小**:
    * 发送方必须同时遵守网络的限制 (`CongWin`) 和接收方的限制 (`rwnd`)。
    * `CongWin` = 10000 字节
    * `rwnd` = 6000 字节
    * 有效窗口 = `min(10000, 6000)` = **6000 字节**。

2.  **确定发送起点 (`SendBase`)**:
    * 根据情景回顾，`SendBase` 已经是 **7500**。这是发送方接下来可以发送的第一个字节。

3.  **计算可发送的最后一个字节**:
    * 发送方可以从字节 7500 开始，连续发送 6000 个字节的数据。
    * 最后一个字节的编号 = 起始字节 + 数量 - 1
    * 最后一个字节 = `SendBase` + `EffectiveWindow` - 1
    * 最后一个字节 = 7500 + 6000 - 1
    * 最后一个字节 = 13500 - 1 = **13499**

**用邮局的例子来理解**:
你的 `SendBase` 是第 7500 页，这是你接下来要寄的第一页。你的有效窗口是 6000 页（因为朋友的信箱只能再装 6000 页）。所以，你可以寄出的页码范围是 **[7500, 7501, ..., 13499]**。总共是 6000 页。

**结论**: 能确保发出的最后一个字节的编号是 **13499**。✅

---

![1755178404822.png](https://youke1.picui.cn/s1/2025/08/14/689de5938143c.png)

好的，我们接着上一部分的内容，来分析这最后两个问题 (Q11 和 Q12)。这个场景是紧接着上一个状态的，非常连贯。

---

### **新的前提设定 (New Premise)**

首先，我们来理解一下这个全新的情况。

**题目原文**:
"Now assume that the sender receives three more TCP segments, such that all three segments have TCP acknowledgement number 7500. Answer the two questions (Q11, Q12) below assuming that all three ACKs are processed and no further ACKs are received."

**中文翻译与解析**:
* **发生了什么**: 在我们上次讨论的状态（`SendBase`=7500, `CongWin`=10000, `rwnd`=6000）之后，发送方又收到了 **三个** TCP 段。
* **关键信息**: 这三个新收到的段，它们的**确认号 (ACK number) 全都是 7500**。
* **事件定性**: 我们之前已经收到过一个 ACK 7500（这让 `SendBase` 变成了 7500）。现在又连续收到了三个同样的 ACK，这就构成了 TCP 中一个非常重要的事件——**“3 个重复的 ACK” (3 Duplicate ACKs)**。

**用邮局的例子来理解**:
你之前寄出了一批信，朋友回信说“我收到了 7499 页，正在等 7500 页”（这就是第一个 ACK 7500 的意思）。
紧接着，你又连续收到了**三封一模一样**的回信，内容全都是“我还在等 7500 页！”。这说明什么？这说明朋友很可能收到了 7500 页之后的某些页（比如 7600，7700），但他唯独卡在了 7500 页，所以他只能反复地告诉你他缺的到底是哪一页。


---

### **Q11: `CongWin` 的值是多少？**

**题目原文**: "What is the value of CongWin? Explain your answer in 1 sentence."
**标准答案**: Since the sender receives three duplicate ACKs, the CongWin is reduced to half the current value (current value = 10000 bytes), which is 5000 bytes.
(因为发送方收到了三个重复的ACK，拥塞窗口 `CongWin` 会减至当前值的一半（当前值为10000字节），也就是5000字节。)

#### **核心概念：快速恢复 (Fast Recovery)**
当发生“3个重复ACK”事件时，TCP Reno 认为这只是一个“小拥堵”（可能只是丢了一个包），而不是灾难性的网络崩溃（超时）。因此，它的反应也相对“温和”。

* **TCP Reno 的规则**: 将拥塞窗口 `CongWin` **减半**。
* **邮局的比喻**: 邮局系统发现路上只是偶尔有信件丢失，而不是全线瘫痪。于是它告诉你：“路况有点小问题，你下次寄信的批量（`CongWin`）减半吧，从 10000 减到 5000，我们谨慎一点。”

#### **解题步骤详述**
1.  **事件发生前的 `CongWin`**: 根据上一个问题的设定，在收到这三个重复 ACK 之前，`CongWin` 的值是 **10,000** 字节。
2.  **触发事件**: 收到了 3 个重复的 ACK。
3.  **执行规则**: TCP Reno 对此事件的响应是 `CongWin = CongWin / 2`。
4.  **计算新值**: 新的 `CongWin` = 10,000 / 2 = **5,000** 字节。

**结论**: `CongWin` 的新值为 **5000**。✅

---

### **Q12: 发送方下一个要发送的段的序列号是多少？**

**题目原文**: "What is the sequence number of the next segment that will be transmitted by the sender? Explain your answer in 1 sentence."
**标准答案**: Since the sender received three duplicate ACKs for 7500, it will now retransmit the segment with sequence number 7500.
(因为发送方收到了关于7500的三个重复ACK，它现在将要重传序列号为7500的那个段。)

#### **核心概念：快速重传 (Fast Retransmit)**
这个机制和上面的“快速恢复”是配套的。“3个重复ACK”不仅告诉发送方要降低速度，更重要的，它清楚地指出了**哪一个包可能丢失了**。

* **TCP Reno 的逻辑**: 如果我反复收到对方在请求同一个序列号，那我不用等超时了，我“立刻、马上”把这个包重传一次。
* **邮局的比喻**: 你连续收到三封信，都在喊“我要第 7500 页！”。你立刻就明白了，肯定是第 7500 页在路上寄丢了。你最该做的事情，就是马上从你的底稿里找出第 7500 页，给它重新寄一次！

#### **解题步骤详述**
1.  **分析重复ACK的内容**: 所有重复的 ACK，它们的确认号都是 **7500**。
2.  **理解确认号的含义**: 确认号 7500 代表接收方正在等待以 7500 作为起始序列号的数据段。
3.  **触发快速重传**: 收到三个这样的重复请求，强烈暗示序列号为 7500 的那个数据段已经丢失。
4.  **执行操作**: “快速重传”机制被触发，发送方会立即重传这个被认为丢失的数据段。

**结论**: 发送方下一个要发送的，将是**重传**的、序列号为 **7500** 的数据段。✅

---

![1755178633788.png](https://youke1.picui.cn/s1/2025/08/14/689de678eb3a6.png)
![1755178643222.png](https://youke1.picui.cn/s1/2025/08/14/689de68125a8b.png)

好的，我们来分析这最后一部分关于 TCP 在路由切换时如何应对的习题。这是一个非常实际且重要的问题，它揭示了 TCP 设计中的一些关键权衡。

---

### **核心前提设定 (Core Premise)**

首先，我们必须理解这个场景的核心变化。

**题目原文**:
"Suppose two hosts have a long-lived TCP session over a path with a 100 msec round-trip time (RTT). Then, a link fails, causing the traffic to flow over a longer path with a 500 msec RTT."

**中文翻译与解析**:
* **初始状态**: 两个主机之间有一个长期稳定的 TCP 连接，数据在一个快速路径上传输，**往返时间 (RTT) 是 100 毫秒**。
* **突发事件**: 网络中一个链路突然**故障**。
* **新状态**: 为了绕过故障点，网络流量被切换到一条**更长的备用路径**上。在这条新路径上，**RTT 变成了 500 毫秒**。

**关键冲突**: 整个问题的核心在于，TCP 对网络状况的“认知”（基于旧的 100ms RTT）与“现实”（新的 500ms RTT）之间产生了巨大的、瞬时的鸿沟。


---

### **Q11: 为什么即使没有丢包，发送方还是会重传？**

**题目原文**: "Suppose the router on the left recognizes the failure immediately and starts forwarding data packets over the new path, without losing any packets... Why might the TCP sender retransmit some of the data packets anyway?"
**标准答案**: TCP bases its retransmission timeout (RTO) on an estimate of the round-trip time... When the failure occurs, the increase in the actual round-trip time implies that the ACK packets will not arrive before the RTO expires. This causes the sender to presume the data packets have been lost, leading to retransmissions, despite the fact that no packets were actually lost.
(TCP 的重传超时(RTO)是基于对往返时间的估算... 当故障发生时，实际往返时间的增加意味着 ACK 包无法在 RTO 到期前到达。这导致发送方假定数据包已丢失，从而进行重传，尽管事实上没有数据包丢失。)

#### **核心概念：超时计时器 (RTO) 与 伪重传**
1.  **TCP 如何设定闹钟 (RTO)**: TCP 不知道网络的确切 RTT，它是通过不断测量 ACK 返回的时间来**估算** RTT 的。基于这个估算值（比如 `EstimatedRTT` ≈ 100ms），它会设定一个“闹钟”——**重传超时 (RTO)**。这个闹钟的时长会比估算的 RTT 稍长一些（比如 200ms），以应对网络正常的微小波动。如果闹钟响了，但 ACK 还没到，TCP 就认为包丢了。
2.  **伪重传 (Spurious Retransmission)**: 当一个数据包**没有丢失**，只是它的 ACK 因为网络延迟而“迟到”了，但发送方的“闹钟”设得太短，提前响了，导致发送方错误地重传了这个包。这次重传就是一次“伪重传”。

#### **解题步骤详述**
1.  **故障前的状态**: 在链路切换前，TCP 已经适应了 100ms 的 RTT。它内部的 RTO “闹钟”被设定在了一个较短的值，比如 200ms。
2.  **数据包的漫长旅程**: 假设在切换的瞬间，发送方刚发出了一个数据包。这个包（以及它的 ACK）现在必须走那条 500ms 的新路径。
3.  **耐心不足的闹钟**: 发送方的 200ms 闹钟已经开始倒计时。它并不知道网络路径已经变了，它仍然期望在 200ms 内收到 ACK。
4.  **闹钟提前响起**: 显然，200ms 的闹钟会比需要 500ms 才能返回的 ACK **先到期**。
5.  **错误的结论**: 从发送方的角度看，闹钟响了就是丢包的唯一信号。它无法区分“包真的丢了”和“ACK 只是在路上堵了很久”。
6.  **不必要的重传**: 发送方只能得出“包丢了”的结论，并立即**重传**这个数据包。过了一会儿（300ms 后），第一个包的 ACK 才姗姗来迟。

**结论**: 因为发送方的 RTO (超时闹钟) 是基于旧的、短的 RTT (100ms) 设定的，它没有足够的耐心去等待在新的、长的 RTT (500ms) 路径上的 ACK 返回，因此会过早地触发超时和不必要的重传。✅

---

### **Q12: 如果所有在途数据包都丢失了，拥塞窗口会变成多少？**

**题目原文**: "Suppose instead that the routers do not switch to the new paths all that quickly, and the data packets (and ACK packets) in flight are all lost. What new congestion window size does the TCP sender use? Explain your answer."
**标准答案**: ...in this case, all packets in flight are lost, so no ACKs are received, forcing the sender to detect the loss via a timeout. Timeout-based loss detection leads the sender to set the congestion window to 1 (i.e., 1 MSS).
(...在这种情况下，所有在途数据包都丢失了，所以收不到ACK，这迫使发送方通过超时来检测丢包。基于超时的丢包检测会导致发送方将拥塞窗口设为1（即1个MSS）。)

#### **核心概念：两种丢包检测机制的抉择**
TCP 有两种发现丢包的方式，它们的后果截然不同：
1.  **3 个重复的 ACK**: 需要网络中**仍有数据包在传输**，接收方才能通过发送重复 ACK 来告知发送方“我缺了某个包”。这被视为**轻度拥塞**，`CongWin` 会**减半**。
2.  **超时 (Timeout)**: 发送方在设定时间内**什么都没收到**——既没有新的 ACK，也没有重复的 ACK。网络仿佛陷入了“死寂”。这被视为**重度拥塞或故障**，是 TCP 能遇到的最糟糕情况。

#### **解题步骤详述**
1.  **分析事件**: 题目设定了一个极端情况：所有在途的数据包和 ACK 包**全部丢失**。
2.  **发送方的视角**: 发送方发了一批数据后，就陷入了漫长的、死寂般的等待。它收不到任何来自接收方的反馈。
3.  **哪种检测机制会触发？**:
    * **“3个重复ACK”不可能触发**，因为能触发它的那些后续包和 ACK 包本身也都丢了，接收方根本没机会生成重复 ACK。
    * 因此，发送方唯一能依赖的，就是为最早的那个未确认数据包设定的 **RTO 闹钟**。
4.  **对超时的反应**: 当 RTO 闹钟最终响起，TCP 会启动它最保守、最严厉的拥塞控制策略，因为它必须假设网络已经崩溃。
5.  **设置新的拥塞窗口**: 应对超时的标准操作是：将拥塞窗口 `CongWin` **重置为最小值 1 MSS**。

**结论**: 因为所有数据包丢失导致了超时，发送方会将拥塞窗口 `CongWin` 调整为 **1 MSS**，然后进入慢启动阶段，小心翼翼地重新探测新路径的网络容量。✅