[![1755097366253.png](https://youke1.picui.cn/s1/2025/08/13/689ca9054e94e.png)](https://youke1.picui.cn/s1/2025/08/13/689ca9054e94e.png)

好的，我们来详细分析这道关于**距离向量（Distance Vector）路由协议**特性的选择题。

根据您图片中的反馈，这道题的**唯一正确答案**是第四项：**`Poison reverse may not always resolve the count to infinity problem.` (毒性逆转并不总能解决计数到无穷的问题。)**

下面我们来逐一分析每个选项，解释为什么它是对是错。

---
### **选项分析**

#### **1. `Every router in the network knows the entire network topology.` (网络中的每个路由器都知道整个网络的拓扑结构。)**

* **结论**: **错误 (FALSE)**
* **原因**: 这是对**链路状态 (Link-State)** 协议（如OSPF）的描述。在链路状态协议中，每个路由器都会构建一张完整的网络“地图”。而**距离向量 (Distance Vector)** 协议的工作方式完全不同，它遵循“通过传闻学习路由”(routing-by-rumor)。每个路由器**只了解**与它直接相连的邻居，以及这些邻居告诉它的路由信息。它对超出邻居范围的网络结构一无所知。

---
#### **2. `A reduction in the cost of a link connected to a router will always trigger a distance vector update to be sent from this router.` (与路由器相连的链路成本降低，将总会触发该路由器发送距离向量更新。)**

* **结论**: **错误 (FALSE)**
* **原因**: 关键词是 **`always` (总会)**。当一个链路成本降低时（这是“好消息”），路由器会重新计算它的距离向量表。但是，它**只有在计算结果导致它自己的最短路径表发生改变时**，才会向邻居发送更新。
* **举例**: 假设路由器A有两条路可以去往Z：一条经过B，成本是10；另一条经过C，成本是5。A的最短路径是通过C。现在，A到B的链路成本从10降低到了8。虽然成本降低了，但通过C的路径成本（5）仍然是最低的。因此，A的最终路由表没有变化，它也就不会发送更新。

---
#### **3. `The distance vector sent by each router is propagated to all other routers in the network.` (每个路由器发送的距离向量会被传播到网络中的所有其他路由器。)**

* **结论**: **错误 (FALSE)**
* **原因**: 这是距离向量协议的一个核心特点：信息**只在直接邻居之间**交换。路由器A只会把它自己的距离向量发送给B和C。B和C收到后，会用这些信息更新它们自己的向量，然后再把**它们自己**的向量发给它们的邻居。A最初的那个向量并不会被“原封不动”地传播下去。

---
#### **4. `Poison reverse may not always resolve the count to infinity problem.` (毒性逆转并不总能解决计数到无穷的问题。)**

* **结论**: **正确 (TRUE)**
* **原因**: 毒性逆转 (Poison Reverse) 是一个很有效的优化，它能很好地解决两个节点之间的路由环路问题。但是，当环路涉及到**三个或更多节点**时，毒性逆转就可能失效，无法阻止“计数到无穷”的发生。这是一个距离向量协议（即使经过优化）的固有局限性。

---

[![1755097640087.png](https://youke1.picui.cn/s1/2025/08/13/689caa176a707.png)](https://youke1.picui.cn/s1/2025/08/13/689caa176a707.png)

好的，我们来详细解析这道关于**距离向量（Distance Vector）** 路由协议和**毒性逆转（Poisoned Reverse）** 的问题。

这道题的核心是考察您是否理解“毒性逆转”这一规则在路由更新中的具体应用。

---
### **第一步：分析初始网络和最短路径**

1.  **网络结构**: A — B — C，是一个简单的线性网络。
2.  **链路成本**: `cost(A, B) = 1`, `cost(B, C) = 1`。
3.  **算法**: 距离向量路由，并启用了毒性逆转。
4.  **问题**: 在网络收敛前的**最后一次**更新中，节点A向节点B通告的、关于目的地C的成本是多少？

### **第二步：模拟距离向量的收敛过程**

我们来模拟一下各个节点是如何通过交换信息来学习整个网络的路由的。

* **初始状态 (t=0)**:
    * `A` 只知道它能以成本 **1** 到达邻居 `B`。它对 `C` 一无所知（成本为无穷大 `inf`）。
    * `B` 知道它能以成本 **1** 到达 `A`，以成本 **1** 到达 `C`。
    * `C` 只知道它能以成本 **1** 到达邻居 `B`。

* **第一次信息交换 (t=1)**:
    * 节点 `A` 从它的邻居 `B` 那里收到了 `B` 的距离向量。`B` 告诉 `A`：“我可以以成本 **1** 到达 `C`”。
    * `A` 据此更新自己的路由表。它计算出自己到 `C` 的路径和成本：
        * 路径: `A → B → C`
        * 成本: `cost(A, B) + B通告的到C的成本` = `1 + 1` = **2**
    * 此时，`A` 已经学习到了到达网络中所有节点的最短路径，它的路由表收敛了：
        * **A → B**: 成本 1 (直连)
        * **A → C**: 成本 2 (经由 B)

### **第三步：应用“毒性逆转”规则**

现在到了问题的关键部分。网络已经收敛，节点 `A` 需要向它的邻居（节点 `B`）发送它最终的距离向量更新。这里就必须应用**毒性逆转**规则。

* **毒性逆转规则**: 如果一个节点（如 `A`）去往某个目的地（`C`）的最佳路径，需要**通过**某个邻居（`B`），那么该节点（`A`）在向这个邻居（`B`）发送路由更新时，必须“撒谎”，告诉这个邻居（`B`）它到那个目的地（`C`）的成本是**无穷大 (infinity)**。

* **应用到本题**:
    1.  节点 `A` 到目的地 `C` 的最短路径是 `A → B → C`。
    2.  这条路径的下一跳是节点 **`B`**。
    3.  因此，当 `A` 准备向 `B` 发送更新时，它必须对关于 `C` 的这条路由进行“毒化”（Poison）。

**结论**: 节点 `A` 会向节点 `B` 通告，它到节点 `C` 的成本是 **`infinity`**（无穷大）。

这样做的目的是为了防止路由环路。如果未来 `B-C` 链路断开，这个“毒化”的信息可以确保 `B` 绝对不会反过来尝试通过 `A` 去访问 `C`，从而避免了“计数到无穷”的问题。

---
### **最终答案**

所以，这道题的正确答案是：

**infinity**

---


[![1755097880121.png](https://youke1.picui.cn/s1/2025/08/13/689cab07a5089.png)](https://youke1.picui.cn/s1/2025/08/13/689cab07a5089.png)

好的，这是一道非常经典的**距离向量（Distance Vector）** 算法计算题。它要求我们站在一个路由器（节点D）的视角，根据从其邻居（B和E）那里收到的路由信息，来更新自己的路由表。

---
### **第一步：梳理已知信息**

1.  **D的直接链路成本**:
    * 到邻居 B 的成本: `c(D, B) = 5`
    * 到邻居 E 的成本: `c(D, E) = 2`

2.  **D收到的距离向量**:
    * **从邻居B收到**: `DV_B = (2, 0, 1, 4, 1)`
      * 这代表 B 到 `A, B, C, D, E` 的成本分别是 `2, 0, 1, 4, 1`。
    * **从邻居E收到**: `DV_E = (4, 1, 5, 2, 0)`
      * 这代表 E 到 `A, B, C, D, E` 的成本分别是 `4, 1, 5, 2, 0`。

### **第二步：讲解核心计算公式**

节点D会使用贝尔曼-福特（Bellman-Ford）方程来更新自己的路由。对每一个目的地（A, B, C, E），D都会分别计算经由B和经由E的路径成本，然后选择其中**成本最低**的作为自己的最佳路径。

`D到目的地X的成本 = Min [ (c(D,B) + B到X的成本), (c(D,E) + E到X的成本) ]`

提供最低成本的那个邻居，就是D去往该目的地的**下一跳 (Next hop)**。

---
### **第三步：逐个计算到每个目的地的路由**

#### **1. 计算到节点 A 的路由**
* **经由 B 的成本**: `c(D, B) + d_B(A) = 5 + 2 = 7`
* **经由 E 的成本**: `c(D, E) + d_E(A) = 2 + 4 = 6`
* **结论**: 最低成本是 **6**，下一跳是 **E**。

#### **2. 计算到节点 B 的路由**
* **经由 B 的成本**: `c(D, B) + d_B(B) = 5 + 0 = 5`
* **经由 E 的成本**: `c(D, E) + d_E(B) = 2 + 1 = 3`
* **结论**: 最低成本是 **3**，下一跳是 **E**。

#### **3. 计算到节点 C 的路由**
* **经由 B 的成本**: `c(D, B) + d_B(C) = 5 + 1 = 6`
* **经由 E 的成本**: `c(D, E) + d_E(C) = 2 + 5 = 7`
* **结论**: 最低成本是 **6**，下一跳是 **B**。

#### **4. 计算到节点 E 的路由**
* **经由 B 的成本**: `c(D, B) + d_B(E) = 5 + 1 = 6`
* **经由 E 的成本**: `c(D, E) + d_E(E) = 2 + 0 = 2`
* **结论**: 最低成本是 **2**，下一跳是 **E**。

---
### **第四步：汇总最终答案**

将以上计算结果填入空格中：

* **Cost to A**: **6**
    * **Next hop node (from D) to get to A**: **E**
* **Cost to B**: **3**
    * **Next hop node (from D) to get to B**: **E**
* **Cost to C**: **6**
    * **Next hop node (from D) to get to C**: **B**
* **Cost to E**: **2**
    * **Next hop node (from D) to get to E**: **E**

---

[![1755098061239.png](https://youke1.picui.cn/s1/2025/08/13/689cabbbc00a4.png)](https://youke1.picui.cn/s1/2025/08/13/689cabbbc00a4.png)

好的，我们来详细解析您新上传的这道题。

这是一道关于**距离向量路由协议 (distance vector routing protocol)** 固有缺点的概念题。

---
### **题干与选项翻译及词汇解释**

**问题 (Question 10):**
> **原句**: What is the problem with the distance vector routing protocol?
> **翻译**: **距离向量路由协议有什么问题？**

**选项 (Select one alternative):**

1.  **`Slow convergence`**
    * **翻译**: **收敛缓慢**
    * **词汇解释**: `Convergence` (收敛) 是一个非常核心的网络术语，它指的是网络中的所有路由器就最佳路径达成一致状态的过程。`Slow convergence` 意味着当网络发生变化（例如一条线路断了），需要花费很长的时间，整个网络才能重新计算并稳定下来。

2.  **`The use of broadcasts`**
    * **翻译**: **使用广播**
    * **词汇解释**: `Broadcasts` (广播) 指的是将一个数据包发送给本地网络上的所有设备。一些早期的距离向量协议（如RIPv1）使用广播来发送路由更新。

3.  **`Routing support for classless networks`**
    * **翻译**: **对无类网络的路支持**
    * **词汇解释**: `Classless networks` (无类网络) 指的是使用CIDR（无类域间路由）的网络，它们可以使用可变长度的子网掩码（如/23, /25）。这与旧的、固定的A、B、C类网络相对。

4.  **`Complex Configuration`**
    * **翻译**: **配置复杂**
    * **词汇解释**: `Configuration` (配置) 指的是网络管理员设置和部署一个协议的步骤和过程。`Complex` 意味着这个过程很复杂、繁琐。

---
### **答案分析**

这道题的正确答案是第一个选项：**Slow convergence (收敛缓慢)**。

我们来分析一下为什么：

* **1. Slow convergence (收敛缓慢)**:
    * **这是距离向量协议最著名、最根本的缺点。** 因为距离向量协议的工作方式是“通过传闻学习路由”（每个路由器只从其邻居那里获取信息），所以当网络发生故障时，坏消息（如链路断开）需要一跳一跳地、非常缓慢地传播到整个网络。这个过程很容易导致**“计数到无穷”（count-to-infinity）**问题，使得网络需要很长时间才能恢复稳定。因此，收敛缓慢是其核心问题。

* **2. The use of broadcasts (使用广播)**:
    * 虽然一些旧的距离向量协议（如RIPv1）确实使用广播，这会消耗一些网络带宽，但这并不能算是它最根本的问题。首先，新版的协议（如RIPv2）已经改用更高效的组播（multicast）。其次，与收敛缓慢可能导致的长时间路由错误相比，广播造成的开销是次要的。所以这个选项不准确。

* **3. Routing support for classless networks (对无类网络的路支持)**:
    * 这个说法具有迷惑性。早期的距离向量协议（RIPv1）**确实不支持**无类网络，这在当时是一个大问题。但是，后来的距离向量协议（如RIPv2, EIGRP）**已经完美地支持**了无类网络。因此，这不能被认为是距离向量协议这一大类协议的普遍问题。

* **4. Complex Configuration (配置复杂)**:
    * 这个说法是**完全错误**的。恰恰相反，距离向量协议（尤其是RIP）以其**配置极其简单**而闻名。通常只需要几条命令就可以让它运行起来。相比之下，链路状态协议（如OSPF）的配置要复杂得多。

### **结论**

综上所述，**收敛缓慢**是距离向量路由协议最核心、最固有的问题，直接导致了“计数到无穷”等一系列连锁反应。因此，它是本题的最佳答案。