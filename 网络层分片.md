## 写在最前的英文
fragment 分片  
inclusive 包含

## 题目
[![1754890339763.png](https://youke1.picui.cn/s1/2025/08/11/6899805677373.png)](https://youke1.picui.cn/s1/2025/08/11/6899805677373.png)  

这是网络层分片的内容。  
MTU（Maximum Transmission Unit, 最大传输单元）
flag中，DF=0允许分片，MF=0后续没有分片，MF=1后续还有分片  
1500Bytes里涵盖了20Byte的header。  
1、从hostA发送到router1，mtu=1500，说明第一段是不需要分片的。R1可以收到完整的1500字节的数据报。  
2、从R1发到R2的MTU是1000，所以需要分片。原始数据报的数据载荷（有效数据）是1500-20的header = 1480 Bytes  
在这个MTU=1000的链路上，每个分片的最大数据载荷是1000-20 = 980  
**片偏移以 8 字节为单位** 数据载荷必须是8的倍数。  
980/8 = 122.5 向下取整得到122 所以每个分片的最大数据湖载荷是122*8 =  976字节  
现在发到R2的就是两个分片：  
分片1：  
数据: 976 字节。  
报头: 20 字节。总大小: 996 字节。  
标志: MF=1 (因为后面还有数据)。  
片偏移: 0 (因为是第一片)   
分片2：  
剩余数据: 1480 - 976 = 504 字节。  
报头: 20 字节。总大小: 524 字节。  
标志: MF=0 (因为是原始数据报的最后一部分)。  
片偏移: 976 / 8 = 122。  
3、接下来从R2发送到R3，996和524这两个分片的大小都超过了R2到R3的MTU512.所以这两个分片都需要再次进行分片。  
在 MTU=512 的链路上，每个分片的最大数据载荷 = 512 (MTU) - 20 (报头) = 492 字节。  
同样，调整为 8 的倍数: floor(492 / 8) = 61。所以最大数据载荷是 61 * 8 = 488 字节。  
处理 R1 发来的“分片 1” (数据 976 B, 原始偏移 0, MF=1)：  
新分片 1.1: 数据 488 字节。MF=1, 偏移=0。  
新分片 1.2: 剩余数据 976 - 488 = 488 字节。MF=1, 偏移=0 + 488/8 = 61。  
处理 R1 发来的“分片 2” (数据 504 B, 原始偏移 122, MF=0)：  
新分片 2.1: 数据 488 字节。MF=1, 偏移=122 (继承父分片的偏移)。  
新分片 2.2: 剩余数据 504 - 488 = 16 字节。这是原始数据报的最后一块数据。  
标志: MF=0。    
片偏移: 122 (父分片偏移) + 488 (刚发走的数据) / 8 = 122 + 61 = 183。  
4、路由器 R3 -> 主机 B  
R3 收到了由 R2 发来的四个新分片，并将它们转发给主机 B。  
最后一个分片是“新分片 2.2”，它的片偏移字段值为 183。  
总计收到了四个分片，分别是上文中的1.1,1.2,2.1,2.2  

---

[![1754893607336.png](https://youke1.picui.cn/s1/2025/08/11/68998d1b04a22.png)](https://youke1.picui.cn/s1/2025/08/11/68998d1b04a22.png)

**当一个已经分好的片需要被再次分片时，新产生的“子分片”的偏移量计算，必须基于其“父分片”的原始偏移量。**  
计算第一个新分片 (400 字节) 的偏移量：  
这个新分片包含的是父分片 (600 字节) 数据中的第一部分。因此，它在原始数据报中的起始位置，与它的父分片完全相同。  
所以，它直接继承父分片的偏移量。  
第一个新分片的偏移 = 900。  
计算第二个新分片 (200 字节) 的偏移量：  
这个新分片的数据紧跟在第一个新分片的数据之后。  
它的起始位置 = 父分片的起始位置 + 第一个新分片的数据长度。  
在计算“片偏移”字段时，我们需要将增加的这段数据长度转换为以 8 字节为单位的偏移量。  
计算公式为: 新偏移 = 父分片偏移 + (第一个新分片的数据长度 / 8)  
代入数值: 新偏移 = 900 + (400 / 8)  
新偏移 = 900 + 50  
新偏移 = 950  
第二个新分片的偏移 = 950。  

---

[![1754894382051.png](https://youke1.picui.cn/s1/2025/08/11/6899901f7655c.png)](https://youke1.picui.cn/s1/2025/08/11/6899901f7655c.png)

2000>1500 需要分片
实际上1500-20=1480一组
那就需要分成
1480+20一组
2000-20-1480+20一组 = 500+20  
第一组偏移量0，第二组偏移量1480/8 = 185  

1480+20的这一组到下一段的1000mtu的需要再次分片  
500+20的这一组不需要  
1000-20 = 980是链路最大数据载荷  
floor(980/8)*8 = 122 * 8 = 976是实际上最大能传送的分片数据载荷大小  
1480的数据被拆成 976 + (1480-976) = 976 + 504  
发往r2的共计三个分片：  
分别是976+504+500  
偏移量分别是0 122 185  
接下来发往r3，MTU是512，最大实际数据载荷是512-20 = 492  
floor(492/8) * 8 = 61 * 8 = 488  
这三个都需要被分片，每个都被分成两个，所以实际上总共被分成了六个分片。  
1.1 488 offset0  
1.2 976-488 = 488 offset 488/8 = 61  
2.1 488 offset 61+488/8 = 122  
2.2 504-488 = 16 offset 122+488/8 = 183  
3.1 488 offset 183+16/8 = 185  
3.2 500-488 = 12 offset 185+488/8 = 185 + 61 = 246  
所以第一问答案6 第二问答案246  

---

[![1754896200755.png](https://youke1.picui.cn/s1/2025/08/11/68999739af1b0.png)](https://youke1.picui.cn/s1/2025/08/11/68999739af1b0.png)

这个740Bytes的分片自带了820的偏移量，要注意。  
MTU540 header20  
540-20=520 实际能传输的数据最大载荷  
floor(520/8) * 8 = 520   
740-20 = 720实际数据量  
那就是一个520，一个200，共计两个分片。  
第一个分片的offset继承之前的820，第二个分片的offset是820+520/8 = 820+65 = 885  

---

[![1754904880972.png](https://youke1.picui.cn/s1/2025/08/11/6899b9210a2eb.png)](https://youke1.picui.cn/s1/2025/08/11/6899b9210a2eb.png)

### **a. 填写分片信息表**

#### **第一步：计算基础数据**

* **原始数据报总大小**: 3220 字节
* **IP 报头**: 20 字节 (无选项)
* **原始数据总载荷**: `3220 - 20 = 3200` 字节
* **链路 MTU**: 1500 字节
* **单个分片最大数据载荷**: `1500 (MTU) - 20 (报头) = 1480` 字节。
    * (检查：`1480 / 8 = 185`，是 8 的倍数，可以直接使用)

#### **第二步：模拟分片过程**

根据题意，路由器将使用最大分片大小，并分为 3 个分片。
* **分片 1** 将携带 `1480` 字节的数据。
    * 剩余数据: `3200 - 1480 = 1720` 字节。
* **分片 2** 也将携带 `1480` 字节的数据。
    * 剩余数据: `1720 - 1480 = 240` 字节。
* **分片 3** 将携带所有剩余的 `240` 字节数据。

#### **第三步：填写表格**

根据上述计算，我们可以填写下表：

| Fragment-no | Fragment size | Starting byte | Ending byte | Fragmentation Offset |
| :---: | :---: | :---: | :---: | :---: |
| **1** | **1500** | **0** | **1479** | **0** |
| **2** | **1500** | **1480** | **2959** | **185** |
| **3** | **260** | **2960** | **3199** | **370** |

**表格各字段计算说明：**
* **Fragment size**: `数据载荷 + 20字节报头`。例如分片3是 `240 + 20 = 260`。
* **Starting byte**: 数据在原始载荷中的起始位置（从0开始）。分片2的起始字节就是分片1的数据长度`1480`。
* **Ending byte**: `起始字节 + 数据载荷 - 1`。例如分片2是 `1480 + 1480 - 1 = 2959`。
* **Fragmentation Offset**: `起始字节 / 8`。例如分片3是 `2960 / 8 = 370`。

### **b. 解释分片开销**

#### **计算与比较**

* **分片后的累积总字节数**: `1500 (分片1) + 1500 (分片2) + 260 (分片3) = 3260` 字节。
* **原始数据报大小**: 3220 字节。
* `3260 > 3220`，分片后的累积大小确实比原始数据报更大了。
* **多出的字节数**: `3260 - 3220 = 40` 字节。

#### **原因解释**

**核心原因在于 IP 报头的复制。**

1.  原始的、未分片的 IP 数据报只有 **1** 个 IP 报头（20字节）。
2.  当它被分成 **3** 个分片后，为了让每一个分片都能成为一个独立的、可以在网络中被路由的 IP 包，系统必须为这 3 个分片 **各自都** 配备一个完整的 IP 报头。
3.  这意味着我们从原来的 1 个报头变成了 3 个报头，净增了 `3 - 1 = 2` 个 IP 报头。
4.  因此，总的开销就是这两个额外报头的大小：`2 * 20 字节/报头 = 40` 字节。

这个 `40` 字节的开销，也恰好是我们上面计算出的差值。

---

[![1754905015300.png](https://youke1.picui.cn/s1/2025/08/11/6899b9a71152f.png)](https://youke1.picui.cn/s1/2025/08/11/6899b9a71152f.png)  

### **第一阶段：在 R1 进行分片 (MTU=1620)**

1.  **初始数据计算**:
    * 原始数据报总大小: 4200 字节
    * IP 报头: 20 字节
    * 原始数据总载荷: `4200 - 20 = 4180` 字节

2.  **R1 分片计算**:
    * R1 出口链路 MTU: 1620 字节
    * 单个分片最大数据载荷: `1620 - 20 = 1600` 字节 (1600 是 8 的倍数)

3.  **R1 生成的分片 (发往 R2)**:
    * **分片 A**: 数据 1600 字节。`MF=1`, 偏移=`0`。
    * **分片 B**: 数据 1600 字节。`MF=1`, 偏移=`1600 / 8 = 200`。
    * **分片 C**: 剩余数据 `4180 - 1600 - 1600 = 980` 字节。`MF=0`, 偏移=`3200 / 8 = 400`。

R1 总共生成了 3 个分片，并将它们发送给了 R2。

### **第二阶段：在 R2 进行再次分片 (MTU=900)**

R2 收到了上述的 A、B、C 三个分片。但其出口链路 MTU 仅为 900 字节，这三个分片（总大小分别为 1620, 1620, 1000 字节）都超过了 900，因此**全部需要再次分片**。

1.  **R2 分片计算**:
    * R2 出口链路 MTU: 900 字节
    * 单个分片最大数据载荷: `900 - 20 = 880` 字节 (880 是 8 的倍数)

2.  **R2 对收到的分片进行再处理**:

    * **处理分片 A (1600B 数据, 偏移 0)**:
        * **最终分片 1**: 数据 880B。
        * **最终分片 2**: 数据 `1600 - 880 = 720`B。

    * **处理分片 B (1600B 数据, 偏移 200)**:
        * **最终分片 3**: 数据 880B。
        * **最终分片 4**: 数据 `1600 - 880 = 720`B。

    * **处理分片 C (980B 数据, 偏移 400)**:
        * **最终分片 5**: 数据 880B。
        * **最终分片 6**: 数据 `980 - 880 = 100`B。 (这是原始数据的最后一部分)


### **最终答案**

首先回答问题的第一部分：
**How many IPv4 fragments does R2 forward on the outgoing link? (R2 向出向链路转发了多少个 IPv4 分片？)**
**答案：6**

接下来，是这 6 个最终分片的详细信息：

| 最终分片编号 | Length (总长度) | MF Flag (MF标志) | Offset (片偏移) |
| :--- | :---: | :---: | :---: |
| **1** | 900 字节 | 1 | 0 |
| **2** | 740 字节 | 1 | 110 |
| **3** | 900 字节 | 1 | 200 |
| **4** | 740 字节 | 1 | 310 |
| **5** | 900 字节 | 1 | 400 |
| **6** | 120 字节 | **0** | **510** |

**计算细节**:
* **Length**: `数据大小 + 20`。例如最终分片6是 `100 + 20 = 120` 字节。
* **MF Flag**: 只有包含原始数据报最后一个字节的分片（即最终分片6），其 MF 标志才为 0，其他都为 1。
* **Offset**: 继承父分片的偏移，并加上新产生的位移。例如最终分片4的偏移 = `分片B的偏移 + (最终分片3的数据/8)` = `200 + (880/8)` = `200 + 110 = 310`。